## **Links**
- https://de.wikipedia.org/wiki/Transmission_Control_Protocol

Transmission Control Protocol (TCP)
- ÃœbertrÃ¤gt Daten zuverlÃ¤ssig Ã¼ber ein unzuverlÃ¤ssige IP-Netz
	- Effektiv gegen
		- Verlorene Daten
		- Korrupte Daten
		- Vertauschte Reihenfolge der Daten
		- Duplikate
- Ã–ffnet eine Verbindung, bevor die Ãœbertragung beginnt
- Reguliert Datenfluss, um Ã¼berlastung des Netzes zu vermeiden
- TCP ist Verbindungsorientiert
- Voll-Duplex Byte-Stream Service
- Bietet **Flusskontrolle** (Flow Control) und **Staukontrolle** (Congestion Control)
- TCP ist byte orientiert, nicht Paket orientiert Aus sicht der Anwendung nur ein fortlaufender Bytestream TCP Ã¼bertrÃ¤gt diesen in Segmenten

## **3-Wege-Handshake** (Verbindungsaufbau)
1. **SYN** â†’ Client sendet SYN mit Initial Sequence Number (ISN)
2. **SYN-ACK** â†’ Server bestÃ¤tigt mit SYN-flag und eigener ISN
3. **ACK** â†’ Client bestÃ¤tigt den Empfang

**Verbindungsabbau** (4-Wege-Handshake):
- Jede Seite sendet **FIN** und erhÃ¤lt **ACK** zurÃ¼ck
- Kann von beiden Seiten initiiert werden
- **Half-close** mÃ¶glich (eine Richtung wird geschlossen)

Ein Segment wird gesendet wenn
- Das Segment voll ist
- Ein Timeout ablÃ¤uft
- Die Applikation ein Signal gibt
## **ZuverlÃ¤ssigkeit**
- Daten werden korrekt Ã¼bermittelt (oder garnicht)
- Daten werden vollstÃ¤ndig Ã¼bermittelt
- Duplikate werden eliminiert
- Daten werden in der korrekten Reihenfolge Ã¼bertragen

### **Typische Fehler und GegenmaÃŸnamen**
- Bitfehler -> Internet Checksum
- Verlust kompletter Nachrichten -> Fehlende BestÃ¤tigung (**ACK**nowledgement)
- Duplikate -> Sequenznummer
- Falsche Reihenfolge -> Sequenznummer

**Automatic Repeat reQuest (ARQ)**
- Sender fordert vom EmpfÃ¤nger eine BestÃ¤tigung (ACK), dass die Daten korrekt empfangen wurden
- Nach Timeout ohne ACk wird das Paket erneut gesendet

Sendet man die nÃ¤chste Nachricht erst, wenn die vorherige erfolgreich Ã¼bertragen wurde, spricht man von "Stop-and-Wait"
- Sehr ineffizient bei kleinen Paketen und hohem Ping

Besser als Stop-and-Wait: Sliding Window
- Sender darf nicht nur ein Segment versenden, sondern N bevor ein ACK erwartet wird
- Wenn Segmente fortlaufend nummeriert werden (Sequenznummer) entsteht ein "Win
- dow" welches die aktuell versendeten Segmente angibt
- Sobald ein Paket bestÃ¤tigt wird, verschiebt sich Anfang und Ende des Window
	- Es entsteht ein "Sliding Window"

Was tut man bei Ãœbertragungsfehlern
- Go-Back-N
	- EmpfÃ¤nger:
		- Wenn Segment mit `seq=n` empfangen wird und Reihenfolge korrekt ist, sende `ACK(n)`
		- Bei falscher Sequenznummer, `seq=n+2` sende weiterhin `ACK(n)` bis `seq=n+1` eintrifft
	- Sehr einfach (kein puffer)
	- Verlust von einem Segment fÃ¼hrt zu vielen unnÃ¶tigen Wiederholungen
- Selective Repeat
	- EmpfÃ¤nger:
		- Individuelle BestÃ¤tigung von jedem Segment das Eintrifft, selbst bei falscher Reihenfolge
		- Empfangspuffer um auf fehlende Segmente warten zu kÃ¶nnen

## **Timeout und Round Trip Time (RTT)**
Wahl des Timeouts
- LÃ¤nger als RTT, aber RTT variiert
- Zu kurz -> UnnÃ¶tig verworfene Segmente
- Zu lang -> Langsame Reaktion bei Fehlern
RTT wird kontinuierlich gemessen, Ã¼ber vergangene erfolgreiche ACKs
`EstimatedRTT = (1-a)*EstimatedRTT + a*SampleRTT`
mit `a` um 0.125

ARQ in der RealitÃ¤t:
- Nicht Segmente sondern Bytes werden bestÃ¤tigt
	- `seq` erhÃ¶ht sich immer um die LÃ¤nge des gesendeten Pakets
		- `seq=1,len=10` -> `seq=11,len=...`
- Es existieren verschiedene TCP-Implementierungen die entweder Go-Back-N, Selective Repeat oder eine Kombination verwenden
## **Flow Control**
- Situation: Der Sender Ã¼bertrÃ¤gt Daten schneller, als der Prozess auf EmpfÃ¤ngerseite sie aus dem Puffer lesen kann (ğœ†ğ‘–ğ‘› > ğœ†ğ‘œğ‘¢ğ‘¡). 
- Folge: Der Empfangspuffer kann Ã¼berlaufen; Segmente wÃ¼rden verworfen â†’ unnÃ¶tige Wiederholungen. 
- LÃ¶sungsansatz: Der EmpfÃ¤nger informiert den Sender Ã¼ber den aktuell verfÃ¼gbaren freien Pufferplatz. 
- Ziel: Der EmpfÃ¤nger steuert die Sendegeschwindigkeit des Senders.
1. Der EmpfÃ¤nger teilt die GrÃ¶ÃŸe des aktuell freien Puffers (receive window (rwnd)) im Window Feld des TCP headers dem Sender mit 
2. Sender limitiert sein Sendefenster basierend auf der GrÃ¶ÃŸe des Puffers beim EmpfÃ¤nger

## **Congestion Control**
### **Problem**
- Viele Sender Ã¼berlasten das Netzwerk
- Folgen: Lange Warteschlangen, Paketverluste, erhÃ¶hter Verkehr durch Retransmissions
### **AnsÃ¤tze**
1. **NetzgestÃ¼tzt** (z.B. **ECN** - Explicit Congestion Notification)
2. **Abgeleitet** (aus Segmentverlusten, RTT-Anstieg, Jitter)
### **AIMD (Additive Increase Multiplicative Decrease)**
- **Additive Increase**: +1 MSS pro RTT bei Erfolg
- **Multiplicative Decrease**: Halbierung bei Verlusten
### **TCP-Algorithmen**
- **TCP Tahoe**: Bei Verlust â†’ cwnd = 1 MSS (konservativ)
- **TCP Reno**: **Fast Recovery** bei 3 Dup-ACKs (cwnd/2)
- **TCP Cubic**: Standard in Linux (fÃ¼r High-BDP-Netze)
- **TCP Westwood:** Forschungsalgorithmus, nie als RFC standardisiert
- **TCP Cubic:** RFC 8312 (Standard in Linux; gut fÃ¼r High-BDP-Netze)
### **Initial Window (IW)**
- Heute: **IW10** (10 MSS, RFC 6928)
- **Slow Start**: Exponentielles Wachstum bis `ssthresh`, dann AIMD

### **NetzgestÃ¼zte Congestion Control**
- Router signalisieren Ãœberlastsituationen an EmpfÃ¤nger, welcher die Information an den Sender kommuniziert. 
- Anpassung bzw. Nutzung von IP/TCP-Headerfeldern 
- Beispiel: TCP ECN (Explicit Congestion Notification), RFC 3168  und RFC 8311 

### **Abgeleitete Congestion Control**
- Ãœberlast wird aus Verbindungsdaten abgeleitet - 
- Segmentverluste, RTT-Anstieg, Jitter, â€¦ 
- Beispiel: TCP (klassisch verlustbasiert)