- **Prinzip:** 
	- Jeder Router kennt nur seine direkten Nachbarn und die Kosten dorthin. Er erfährt die restlichen Routen **indirekt** durch periodischen Austausch mit Nachbarn. 
- **Gespeicherte Informationen:** 
	- Für jedes Zielnetz speichert der Router: 
		- 1. Zieladresse oder -netz
		- 2. Kosten (Metrik, meist Hop-Count)
		- 3. Next Hop (nächster Router-Port)
- **Austauschmechanismus:** 
	- Jeder Router sendet seinen **Distance-Vector** (Liste aller bekannten Ziele mit Kosten) regelmäßig an seine Nachbarn. 
- Berechnung: 
	- Router aktualisieren ihre Tabellen mit dem **Bellman-Ford-Algorithmus** und wählen pro Ziel den günstigsten Next Hop. 
- Vertreter: **RIP, EIGRP (Cisco)**.

Warum ist Count-to-Infinity ein fundamentales Problem? 
- **Beobachtung:** 
	- Distance-Vector-Router lernen nur über ihre Nachbarn – Informationen über Ausfälle verbreiten sich daher langsam und indirekt. 
- **Problem:** 
	- Beim Ausfall eines Pfads glauben Router, dass Nachbarn den Weg noch kennen. ⇒ Sie lehren sich gegenseitig falsche Routen. 
- **Folgen:** 
	- Kosten steigen schrittweise bis ∞ (Count-to-Infinity)
	- Routing-Schleifen, Pakete zirkulieren 
	- Langsame Konvergenz 
- **Lösungen:** 
	- **Split Horizon:** Keine Rückgabe über den Lernweg 
	- **Poisoned Reverse:** Route über Lernweg mit ∞-Kosten ankündigen 
	- **Kostenlimit:** z. B. 16 bei RIP 
- Fazit: Count-to-Infinity ist eine Folge der lokalen, verteilten Sicht im Distance-Vector-Ansatz.